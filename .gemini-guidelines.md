# Charte de Développement Gemini pour Projets Next.js

Ce document définit les conventions et les patrons d'architecture que l'assistant IA Gemini doit suivre pour contribuer à ce projet Next.js.

## 1. Architecture : Clean Architecture & Conventions Next.js

Le projet combine les principes de la Clean Architecture pour la logique métier avec les conventions de structure de Next.js.

### Structure des Dossiers Next.js

-   **`src/app/`**: Contient les routes, pages, et composants spécifiques à une route (`page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx`).
-   **`src/components/`**: Contient les composants d'interface utilisateur (UI) partagés et réutilisables (ex: `Button`, `Card`).
-   **`src/lib/`** (ou `src/utils/`): Contient les fonctions utilitaires, la configuration des bibliothèques, et la logique partagée non-React.
-   **`src/hooks/`**: Contient les hooks React personnalisés (`useWindowWidth`, `useDebounce`).

### Couches de la Clean Architecture (pour la logique métier)

Pour la logique complexe (ex: interactions avec une API externe, processus métier), nous appliquons une séparation stricte des responsabilités.

-   **`src/domain`** (ou `src/core`): Contient la logique métier pure et les types de données.
    -   **Règle** : Les fonctions de cette couche doivent être pures (sans effets de bord comme des appels API ou la lecture de fichiers). Elles ne doivent pas dépendre de React ou de Next.js.
    -   **Règle** : Cette couche ne doit dépendre d'aucune autre couche.

-   **`src/usecase`** (ou `src/application`): Orchestre le flux de données.
    -   **Règle** : Appelle `infra` pour obtenir les données, les transmet au `domain` pour le traitement, et utilise à nouveau `infra` pour persister les résultats.
    -   **Règle** : Ne contient aucune logique métier lui-même.

-   **`src/infra`** (ou `src/infrastructure`): Gère toutes les interactions avec le monde extérieur.
    -   **Règle** : C'est la seule couche autorisée à interagir avec les APIs externes, les bases de données, ou les services tiers. Elle est souvent appelée depuis les `Server Components`, les `Route Handlers` (dans `app/api`) ou les `Server Actions`.

## 2. Langage & Style

-   **Langue** : Tout nouveau code (variables, fonctions, fichiers, commentaires) **DOIT** être écrit en **anglais**.
-   **TypeScript** : Utiliser TypeScript avec le mode `strict` activé dans `tsconfig.json`. Éviter le type `any`.
-   **Formatage** : Le code doit être formaté en respectant les fichiers de configuration `Prettier` et `ESLint` du projet.
-   **Nommage Explicite** : Les noms de variables, fonctions et composants doivent être clairs et décrire leur objectif. Éviter les abréviations.
-   **Signature des Fonctions / Props des Composants** : Une fonction ou un composant ne doit pas accepter plus d'un paramètre. Si plusieurs valeurs sont nécessaires, elles doivent être passées via un unique objet de paramètres (destructuration).
-   **Lisibilité et Abstraction** : Le code doit être auto-documenté. Si un bloc de code (logique ou JSX) nécessite un commentaire pour expliquer *ce qu'il fait*, il doit être extrait dans sa propre fonction ou son propre composant.
-   **Contrôle de Flux** : Privilégier les "guard clauses" (retours anticipés). Pour les rendus conditionnels simples en JSX, préférer les opérateurs ternaires ou logiques (`&&`) aux blocs `if...else`.

## 3. Tests

-   **Règle** : Toute logique métier nouvelle ou modifiée dans la couche `domain` **DOIT** être couverte par des tests unitaires. Les composants critiques doivent également être testés.
-   **Outils** : Utiliser **Jest** avec **React Testing Library** pour les tests unitaires et d'intégration.

## 4. Constantes

-   **Règle** : Éviter les "chaînes magiques" (clés d'API, routes, clés de `localStorage`).
-   **Action** : Centraliser ces valeurs dans un fichier de constantes dédié (ex: `src/lib/constants.ts`).

## 5. Messages de Commit

-   **Convention** : Suivre la spécification [Conventional Commits](https://www.conventionalcommits.org/).
    -   **Exemples** : `feat: add user authentication`, `fix: correct tax calculation`, `refactor: simplify data processing logic`.

## 6. Principes de Programmation Fonctionnelle

-   **Immuabilité (Variables)** : Favoriser `const` par rapport à `let`.
-   **Immuabilité (Données)** : Ne **JAMAIS** muter l'état (`state`), les `props`, ou les objets/tableaux. Créer de nouvelles structures de données avec les valeurs mises à jour (ex: `...spread`).
-   **Code Déclaratif** : Privilégier les méthodes de tableau (`.map()`, `.filter()`, `.reduce()`) aux boucles impératives (`for`). En React, décrire l'UI pour un état donné plutôt que de manipuler le DOM.
-   **Composition** : Décomposer la logique et l'UI en petites fonctions/composants purs et les composer.

## 7. Gestion des Erreurs

-   **Règle (Backend)** : Les opérations à risque (appels API, BDD) dans la couche `infra` ou les `Route Handlers` doivent être encapsulées dans des blocs `try...catch`.
-   **Règle (Frontend)** : Utiliser les mécanismes de Next.js comme les fichiers `error.tsx` pour gérer les erreurs de rendu et éviter que l'application ne plante.

## 8. Bonnes Pratiques Avancées

-   **Optimisation des Recherches** : Pour les recherches répétées dans une liste, convertir la liste en `Map` avant la boucle pour un accès en temps constant O(1).
-   **Sécurité de Type Nominale** : Pour les identifiants, envisager l'utilisation d'`Opaque Types` (souvent définis dans `src/@types/`) pour empêcher les assignations incorrectes entre différents types d'ID.
-   **Injection de Dépendances** : Pour la logique testable (surtout côté serveur), utiliser des fonctions d'ordre supérieur (currying) pour l'injection de dépendances.
-   **Performance React** : Utiliser `React.memo`, `useCallback`, et `useMemo` judicieusement pour éviter les rendus inutiles. Utiliser `next/dynamic` pour le chargement différé des composants non critiques.

## 9. Méthodologie de Développement

-   **Priorité 1 : Type-Driven Development (TDD)**
    -   **Commencer par la modélisation des données.** Avant d'écrire la logique, définir les types, les interfaces (`props` des composants, réponses d'API) et les signatures de fonctions.
    -   **Utiliser le compilateur TypeScript comme un partenaire.** Les erreurs de compilation sont des guides.

-   **Priorité 2 : Test-Driven Development (TDD)**
    -   En complément, pour la logique métier complexe (principalement dans `domain` et `usecase`), appliquer le cycle **"Red-Green-Refactor"**.
    -   1.  **Red** : Écrire un test qui échoue.
    -   2.  **Green** : Écrire le code le plus simple pour que le test passe.
    -   3.  **Refactor** : Améliorer le code sans modifier son comportement.